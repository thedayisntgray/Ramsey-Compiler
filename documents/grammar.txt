<program> -> <toplvlstmts>
<toplvlstmts> -> <toplvlstmt> "\n" <toplvlstmtsA>

<toplvlstmtsA> -> <toplvlstmts>
	| e

<toplvlstmt> -> <stmts>
	| fun <ident> (<opt_params>) as <type> "\n" <fun_stmts> "\n" toss <expr> "\n" endfun 

<stmts> -> <stmt> "\n" <stmtX>


<stmtX> -> <stmts>
	| e

<stmt> -> if (<boolexp>) "\n" <optional_stmts> "\n" <stmtA>
	| while (<boolexp>) "\n" <optional_stmts> "\n" endwhile
	| <ident> <identTail>
	| <type> <ident> <stmtC>
	| <exprB>

<stmtA> -> endif
	|	else "\n" <optional_stmts> "\n" endif
	|	<elves> <stmtB>

<stmtB> -> endif
	| else "\n" <optional_stmts> "\n" endif
	
<stmtC> -> <- <expr>
	| e
	
<identTail> -> <- <expr>
	| <exprTail>

<elves> -> elf (<boolexp>) "\n" <optional_stmts> "\n" <elvesA>

<elvesA> -> <elves>
	| e

<optional_stmts> -> e 
	| <stmts>

<fun_stmts> -> e 
	| <stmts>
	| toss <expr>

<opt_params> -> <params>
	| e

<params> -> <param> <paramsA>

<paramsA> -> , <params>
	| e
	
<param> -> <type> <ident>

<expr> -> <exprA> <exprTail>
	
<exprTail> -> <op> <exprA>
	| e

<exprA> -> <ident>
	| <literal>
	| (<expr>)
	| chop (<expr>)
	
<exprB> -> <literal>
	| (<expr>)
	| chop (<expr>)

<boolexp> -> <boolexpA>
	| NOT <boolexp>
	| (<boolexp>)
	| <ident> <boolop> <boolexpB>
	| <literal> <boolop> <boolexpC>

<boolexpA> -> OR <boolexp>
	| AND <boolexp>

<boolexpB> -> <boolexp>
	| <expr>
	| <ident>
	| <literal>

<boolexpC> -> <ident>
	| <literal>

<type> -> bool
	| in
	| small
	| big

<op> ->   +
	| -
	| *
	| /
	| %

<boolop> -> <
	| <=
	| =
	| >
	| >=
	| !=

<ident> -> from regex
	
<literal> -> from regex
//Add ++ to literals in lexer
